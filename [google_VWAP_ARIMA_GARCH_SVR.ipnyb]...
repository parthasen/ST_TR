library(quantmod)
library(lattice)
library(timeSeries)
library(rugarch)
library( fArma )
#csv file generated from [google_VWAP_ARIMA_GARCH_SVR.ipnyb] python code at Project
#loading data at R
data<-read.table('/home/octo/Desktop/PROJECT/DATA/RPy/data.csv',sep=",",col.names=c("TIME","CLOSE","HIGH","LOW","OPEN","VOLUME"),fill=TRUE)
#deleting first row of dataframe needed for this
data<-data[-1,]
# as.numeric needed to make the columns numeric from pattern
spReturns<-diff(log(as.numeric(data$CLOSE)))
spReturns[as.character(head(index(data$CLOSE)),1)] = 0
# delete the NA from the vector
spReturns<-na.omit(spReturns)

# The maximum draw down
head(drawdownsStats(as.timeSeries(spReturns)),10)

#ARMA model
spyArma = armaFit( formula=~arma(5,5), data=spReturns )
as.numeric( predict( spyArma, n.ahead=5, doplot=F )$pred )

#GARCH MODEL
spyGarch = garchFit(~arma(5,5) + garch(3,3), data=spReturns)
predict(spyGarch, n.ahead=1, doplot=F)

windowLength = 100
foreLength = length(spReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)

for (d in 0:foreLength) {
    # Obtain the S&P500 rolling window for this day
    spReturnsOffset = spReturns[(1+d):(windowLength+d)]

    # Fit the ARIMA model
    final.aic <- Inf
    final.order <- c(0,0,0)
    for (p in 0:5) for (q in 0:5) {
        if ( p == 0 && q == 0) {
            next
        }

        arimaFit = tryCatch( arima(spReturnsOffset, order=c(p, 0, q)),
                             error=function( err ) FALSE,
                             warning=function( err ) FALSE )

        if( !is.logical( arimaFit ) ) {
            current.aic <- AIC(arimaFit)
            if (current.aic < final.aic) {
                final.aic <- current.aic
                final.order <- c(p, 0, q)
                final.arima <- arima(spReturnsOffset, order=final.order)
            }
        } else {
            next
        }
    }

    # Specify and fit the GARCH model
    spec = ugarchspec(
        variance.model=list(garchOrder=c(1,1)),
        mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
        distribution.model="sged"
    )
    fit = tryCatch(
      ugarchfit(
        spec, spReturnsOffset, solver = 'hybrid'
      ), error=function(e) e, warning=function(w) w
    )

    # If the GARCH model does not converge, set the direction to "long" else
    # choose the correct forecast direction based on the returns prediction
    # Output the results to the screen and the forecasts vector
    if(is(fit, "warning")) {
      forecasts[d+1] = paste(index(spReturnsOffset[windowLength]), 1, sep=",")
      print(paste(index(spReturnsOffset[windowLength]), 1, sep=","))
    } else {
      fore = ugarchforecast(fit, n.ahead=1)
      ind = fore@forecast$seriesFor
      forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
      print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=","))
    }
}
