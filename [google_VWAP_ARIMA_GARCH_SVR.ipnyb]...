library(quantmod)
library(lattice)
library(timeSeries)
library(rugarch)
library( fArma )
library( fGarch )
require(tseries)
require(rgarch)
require(urca)
require(ggplot2)
#csv file generated from [google_VWAP_ARIMA_GARCH_SVR.ipnyb] python code at Project
#loading data at R
data<-read.table('/home/octo/Desktop/PROJECT/DATA/RPy/data.csv',sep=",",col.names=c("TIME","CLOSE","HIGH","LOW","OPEN","VOLUME"),fill=TRUE)
#deleting first row of dataframe needed for this
data<-data[-1,]
# as.numeric needed to make the columns numeric from pattern
spReturns<-diff(log(as.numeric(data$CLOSE)))
spReturns[as.character(head(index(data$CLOSE)),1)] = 0
# delete the NA from the vector
spReturns<-na.omit(spReturns)

# The maximum draw down
head(drawdownsStats(as.timeSeries(spReturns)),10)

#ARMA model
# Fit the model
spyArma = armaFit( formula=~arma(6,11), data=spReturns )
#spyArma@fit$aic##testing the lowest AIC
as.numeric( predict( spyArma, n.ahead=5, doplot=F )$pred )

#ARIMA model
spyArima<-arima(spReturns, order=c(5,1,5))
acf(spyArima$residuals)
fore <- predict(spyArima, n.ahead=24)
ressq<-(spyArima$residuals)^2
Box.test(ressq, lag = 8, type = "Ljung-Box")
pacf(ressq, main="PACF of Squared Residuals", lag = 30)
# error bounds at 95% confidence level
U <- fore$pred + 2*fore$se
L <- fore$pred - 2*fore$se
ts.plot(as.ts(spReturns), fore$pred, U, L, col=c(1,2,4,4), lty = c(1,1,2,2))
legend("topleft", c("Actual", "Forecast", "Error Bounds (95% Confidence)"),col=c(1,2,4), lty=c(1,1,2))

#GARCH MODEL
spyGarch = garchFit(~arma(5,5) + garch(3,3), data=spReturns)
predict(spyGarch, n.ahead=1, doplot=F)

spyGarch <- ugarchspec(variance.model=list(model="eGARCH", garchOrder=c(3,3), submodel = NULL),
        mean.model=list(armaOrder=c(5,5), include.mean=TRUE, garchInMean = TRUE))
fit <- ugarchfit(data = spReturns, spec =spyGarch)
fit
fittedmodel <- fit@fit
sigma<-fittedmodel$sigma
fitm <- ugarchfit(data = spReturns,out.sample = 10, spec =spyGarch)
pred <- ugarchforecast(fitm, n.ahead = 10,n.roll = 1)
pred.fpm <- fpm(pred)

windowLength = 100
foreLength = length(spReturns) - windowLength
forecasts <- vector(mode="character", length=foreLength)

for (d in 0:foreLength) {
    # Obtain the S&P500 rolling window for this day
    spReturnsOffset = spReturns[(1+d):(windowLength+d)]

    # Fit the ARIMA model
    final.aic <- Inf
    final.order <- c(0,0,0)
    for (p in 0:5) for (q in 0:5) {
        if ( p == 0 && q == 0) {
            next
        }

        arimaFit = tryCatch( arima(spReturnsOffset, order=c(p, 0, q)),
                             error=function( err ) FALSE,
                             warning=function( err ) FALSE )

        if( !is.logical( arimaFit ) ) {
            current.aic <- AIC(arimaFit)
            if (current.aic < final.aic) {
                final.aic <- current.aic
                final.order <- c(p, 0, q)
                final.arima <- arima(spReturnsOffset, order=final.order)
            }
        } else {
            next
        }
    }

    # Specify and fit the GARCH model
    spec = ugarchspec(
        variance.model=list(garchOrder=c(1,1)),
        mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
        distribution.model="sged"
    )
    fit = tryCatch(
      ugarchfit(
        spec, spReturnsOffset, solver = 'hybrid'
      ), error=function(e) e, warning=function(w) w
    )

    # If the GARCH model does not converge, set the direction to "long" else
    # choose the correct forecast direction based on the returns prediction
    # Output the results to the screen and the forecasts vector
    if(is(fit, "warning")) {
      forecasts[d+1] = paste(index(spReturnsOffset[windowLength]), 1, sep=",")
      print(paste(index(spReturnsOffset[windowLength]), 1, sep=","))
    } else {
      fore = ugarchforecast(fit, n.ahead=1)
      ind = fore@forecast$seriesFor
      forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")
      print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=","))
    }
}
